<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documented recipe with all features · DataCurator Documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="DataCurator Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">DataCurator Documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Index</a></li><li><a class="tocitem" href="installation.html">Installation</a></li><li class="is-active"><a class="tocitem" href="documented_recipe.html">Documented recipe with all features</a><ul class="internal"><li><a class="tocitem" href="#A-recipe-using-all/most-of-the-possible-features"><span>A recipe using all/most of the possible features</span></a></li><li><a class="tocitem" href="#Modifying-files-and-content"><span>Modifying files and content</span></a></li><li><a class="tocitem" href="#Under-the-hood"><span>Under the hood</span></a></li></ul></li><li><a class="tocitem" href="reference.html">API Reference</a></li><li><a class="tocitem" href="conditions.html">Conditions and Actions for use in recipes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="documented_recipe.html">Documented recipe with all features</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="documented_recipe.html">Documented recipe with all features</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bencardoen/DataCurator.jl/blob/master/docs/src/documented_recipe.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="A-recipe-using-all/most-of-the-possible-features"><a class="docs-heading-anchor" href="#A-recipe-using-all/most-of-the-possible-features">A recipe using all/most of the possible features</a><a id="A-recipe-using-all/most-of-the-possible-features-1"></a><a class="docs-heading-anchor-permalink" href="#A-recipe-using-all/most-of-the-possible-features" title="Permalink"></a></h2><p>First, a recipe is a plain text file, in TOML format, designed to be as human friendly as possible.</p><p>We&#39;ll run through all, or most of the features you can use, with example TOML snippets.</p><ul><li class="no-marker"><ul><li><a href="documented_recipe.html#A-recipe-using-all/most-of-the-possible-features">A recipe using all/most of the possible features</a></li><li class="no-marker"><ul><li><a href="documented_recipe.html#Global-section">Global section</a></li><li class="no-marker"><ul><li><a href="documented_recipe.html#Saved-actions-and-conditions">Saved actions and conditions</a></li><li><a href="documented_recipe.html#Aggregation">Aggregation</a></li><li class="no-marker"><ul><li><a href="documented_recipe.html#Counters">Counters</a></li><li><a href="documented_recipe.html#Files-to-process">Files to process</a></li><li><a href="documented_recipe.html#Image-aggregation">Image aggregation</a></li><li class="no-marker"><ul><li><a href="documented_recipe.html#Stacking-2D-images">Stacking 2D images</a></li><li><a href="documented_recipe.html#Maximum-projection-of-3D-images-along-the-Y-axis,-then-stack-them.">Maximum projection of 3D images along the Y axis, then stack them.</a></li><li><a href="documented_recipe.html#Describe-intensity-of-each-image,-per-slice,-and-concatenate-to-table">Describe intensity of each image, per slice, and concatenate to table</a></li><li><a href="documented_recipe.html#Stack-images,-sorting-by-prefix">Stack images, sorting by prefix</a></li></ul></li><li><a href="documented_recipe.html#Table-aggregation">Table aggregation</a></li></ul></li></ul></li><li><a href="documented_recipe.html#Template">Template</a></li><li class="no-marker"><ul><li><a href="documented_recipe.html#Flat-templates,-the-Any-section">Flat templates, the Any section</a></li><li><a href="documented_recipe.html#Hierarchical-templates,-with-level_X">Hierarchical templates, with <code>level_X</code></a></li></ul></li><li><a href="documented_recipe.html#Advanced-usage">Advanced usage</a></li><li class="no-marker"><ul><li class="no-marker"><ul><li><a href="documented_recipe.html#Verify-a-complex,-deep-dataset-layout.">Verify a complex, deep dataset layout.</a></li><li class="no-marker"><ul><li><a href="documented_recipe.html#Global-section-2">Global section</a></li><li><a href="documented_recipe.html#The-template">The template</a></li></ul></li><li><a href="documented_recipe.html#Early-exit:">Early exit:</a></li><li><a href="documented_recipe.html#Regular-expressions:">Regular expressions:</a></li><li><a href="documented_recipe.html#Negating-conditions:">Negating conditions:</a></li><li><a href="documented_recipe.html#Counteractions:">Counteractions:</a></li><li><a href="documented_recipe.html#Export-to-HDF5/MAT">Export to HDF5/MAT</a></li></ul></li></ul></li></ul></li><li><a href="documented_recipe.html#Modifying-files-and-content">Modifying files and content</a></li><li class="no-marker"><ul><li class="no-marker"><ul><li><a href="documented_recipe.html#Select-rows-from-CSVs-and-save-them">Select rows from CSVs and save them</a></li></ul></li><li><a href="documented_recipe.html#Aggregation-2">Aggregation</a></li><li class="no-marker"><ul><li><a href="documented_recipe.html#The-maximum-projection-of-2D-images">The maximum projection of 2D images</a></li><li><a href="documented_recipe.html#The-complete-grammar:">The complete grammar:</a></li></ul></li></ul></li><li><a href="documented_recipe.html#Under-the-hood">Under the hood</a></li></ul></li></ul><p>Any <code>recipe</code> needs 2 parts, the global configuration, and the actual template.</p><p>The global configuration specifies <strong>how</strong> the template is applied, the template specifies the conditions/rules to apply, i.o.w. the <strong>what</strong> and <strong>when</strong>.</p><p>A <em>section</em> in a TOML file is simply:</p><pre><code class="language-toml hljs">[mysectionname]
mycontent=&quot;some value&quot;</code></pre><h3 id="Global-section"><a class="docs-heading-anchor" href="#Global-section">Global section</a><a id="Global-section-1"></a><a class="docs-heading-anchor-permalink" href="#Global-section" title="Permalink"></a></h3><pre><code class="language-toml hljs">[global]</code></pre><p>All a minimum global section needs is where to start:</p><pre><code class="language-toml hljs">inputdirectory=&quot;your/directory&quot;</code></pre><p>Next, we can either act on failure (usually in validation), or on success. This simply means that, if set to false, we check for any data that <strong>fails</strong> the rule you specify, then execute your actions. In datacuration you&#39;ll want the inverse, namely, act on success.</p><div class="admonition is-success"><header class="admonition-header">You can have your cake and eat it</header><div class="admonition-body"><p>You can specify <code>actions</code> AND <code>counter_actions</code>, allowing you to specify what to do if a rule applies, and what if it doesn&#39;t. In other words, you have maximal freedom of expression.</p></div></div><pre><code class="language-toml hljs">act_on_success=false # default</code></pre><p>We can also specify how we traverse data, from the deepest to the top (<code>bottomup</code>), or <code>topdown</code>. If you intend to modify files/directories in place, <code>bottomup</code> is the safer option.</p><pre><code class="language-toml hljs">traversal=&quot;bottomup&quot; # or topdown</code></pre><p>We can validate or curate data in parallel, to maximize throughput. Especially on computing clusters this can speed up completion time. If true, will use as many threads as JULIA_NUM_THREADS (usually nr of HT cores).</p><div class="admonition is-info"><header class="admonition-header">Thread safety</header><div class="admonition-body"><p>You do not need to worry about <code>data races</code>, where you get non-deterministic or corrupt results, if you stick to our conditions and aggregations, there are no conflicts between threads.</p></div></div><pre><code class="language-toml hljs">parallel=true #default false</code></pre><p>By default your rules are applied without knowing how deep your are in your dataset. However, at times you will need to know this, for example, to verify that certain files only appear in certain locations, or check naming patterns of directories. For example, a path like <code>top/celltype/cellnr</code> will have a rule to check for a cell number (integer) at level 3, not anywhere else. To enable this:</p><pre><code class="language-toml hljs"># If true, your template is more precise, because you know what to look for at certain levels [level_i]
# If false, define your template in [any]
hierarchical=true</code></pre><p>For more complex pattern matching you may want to use Regular Expressions (regex), to enable this:</p><pre><code class="language-toml hljs"># If true, functions accepting patterns (endswith, startswith), will have their argument converted to a regular expression (using PRCE syntax)
regex = false</code></pre><p>The inputdirectory should point to your dataset. The outputdirectory is where global output is written, e.g. output of aggregation.</p><pre><code class="language-toml hljs">inputdirectory=...
outputdirectory=...</code></pre><h4 id="Saved-actions-and-conditions"><a class="docs-heading-anchor" href="#Saved-actions-and-conditions">Saved actions and conditions</a><a id="Saved-actions-and-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Saved-actions-and-conditions" title="Permalink"></a></h4><p>Quite often you will define actions and conditions several time. Instead of repeating yourself, you can define actions and conditions globally, and then refer from your template to them later. For example:</p><pre><code class="language-toml hljs">common_actions = {react=[[&quot;all&quot;, &quot;show_warning&quot;, [&quot;log_to_file&quot;, &quot;errors.txt&quot;], &quot;remove&quot;]]}
common_conditions = {is_3d_channel=[[&quot;all&quot;, &quot;is_tif_file&quot;, &quot;is_3d_img&quot;, &quot;filename_ends_with_integer&quot;]]}</code></pre><p>In your template you can then do</p><pre><code class="language-toml hljs">actions=[&quot;react&quot;]</code></pre><p>instead of</p><pre><code class="language-toml hljs">actions=[[&quot;all&quot;, &quot;show_warning&quot;, [&quot;log_to_file&quot;, &quot;errors.txt&quot;], &quot;remove&quot;]]]</code></pre><p>This is useful because:     - default actions/conditions are more concisely expressed and reused     - composing complex rules without running out of screen real estate     - more legible     - if you want to change a complex rule, you only need to do so in 1 place     - for Julia, instead of multiple executable rules, there&#39;s now 1</p><p>The reference syntax is</p><pre><code class="nohighlight hljs">common_..={name1=[[&quot;all&quot;, f1, f2, f3, ...]], name2=...}</code></pre><p>Where f1, f2, ... are conditions/actions, and <code>name1</code> will be a placeholder you can reference later to.</p><div class="admonition is-info"><header class="admonition-header">Nested [[]]</header><div class="admonition-body"><p>Here you need to use the explicit nested form for anything more than 1 action/condition, because <code>all=true</code> is implied. Note that this section is parsed before the template itself is seen at all.</p></div></div><p>!!! warning Common actions/conditions cannot refer to others when you&#39;re defining them.     If this was possible, we&#39;d run the risk of deadlock, where actions refer to themselves in a loop, for example. If you need this kind of functionality, it&#39;s better to use the Julia API.</p><h4 id="Aggregation"><a class="docs-heading-anchor" href="#Aggregation">Aggregation</a><a id="Aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#Aggregation" title="Permalink"></a></h4><p>Aggregation is a complex word for use cases like:</p><ul><li>counting files matching a pattern</li><li>counting total size of a selection of files</li><li>making lists of input/output pairs for pipelines</li><li>combining 2D images into 1 3D image</li><li>combining 2D images, sorted by prefix (e.g. &#39;abc<em>1.tif&#39;, &#39;abc</em>2.tif&#39;, &#39;cde<em>1.tif&#39;, &#39;cde</em>2.tif&#39; -&gt; abc.tif, cde.tif)</li><li>selecting specific columns from each csv you find, and fusing all in 1 table</li><li>...</li></ul><p>You can do any of these all at the same time with <code>counters</code> and <code>file_lists</code> in the global section:</p><h5 id="Counters"><a class="docs-heading-anchor" href="#Counters">Counters</a><a id="Counters-1"></a><a class="docs-heading-anchor-permalink" href="#Counters" title="Permalink"></a></h5><pre><code class="language-toml hljs">counters = [&quot;C1&quot;, [&quot;C2&quot;, &quot;size_of_file&quot;]]</code></pre><p>Here we created 2 counters, one that is incremented whenever you refer to it, and one that when you pass it a fily, records it total size in bytes. When the program finishes, these counters are printed.</p><h5 id="Files-to-process"><a class="docs-heading-anchor" href="#Files-to-process">Files to process</a><a id="Files-to-process-1"></a><a class="docs-heading-anchor-permalink" href="#Files-to-process" title="Permalink"></a></h5><p>The simplest kind just adds a file each time you refer to it, and writes them out in traversal order (per thread if parallel) at the end to &quot;infiles.txt&quot;</p><pre><code class="language-toml hljs">file_lists = [&quot;infiles&quot;]</code></pre><p>To make input-output pairs you&#39;d do</p><pre><code class="language-toml hljs">file_lists = [&quot;infiles&quot;, [&quot;outfiles&quot;, &quot;outputpath&quot;]]</code></pre><p>Let&#39;s say we add a file &quot;a/b/c.txt&quot; to infiles, when we add it to outfiles it will be recorded as: &quot;/outputpath/a/b/c.txt&quot; This is a common use case in preparing large batch scripts on SLURM clusters.</p><h5 id="Image-aggregation"><a class="docs-heading-anchor" href="#Image-aggregation">Image aggregation</a><a id="Image-aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#Image-aggregation" title="Permalink"></a></h5><h6 id="Stacking-2D-images"><a class="docs-heading-anchor" href="#Stacking-2D-images">Stacking 2D images</a><a id="Stacking-2D-images-1"></a><a class="docs-heading-anchor-permalink" href="#Stacking-2D-images" title="Permalink"></a></h6><pre><code class="language-toml hljs">file_lists = [{name=&quot;3dstack.tif&quot;, aggregator=&quot;stack_images&quot;}]</code></pre><h6 id="Maximum-projection-of-3D-images-along-the-Y-axis,-then-stack-them."><a class="docs-heading-anchor" href="#Maximum-projection-of-3D-images-along-the-Y-axis,-then-stack-them.">Maximum projection of 3D images along the Y axis, then stack them.</a><a id="Maximum-projection-of-3D-images-along-the-Y-axis,-then-stack-them.-1"></a><a class="docs-heading-anchor-permalink" href="#Maximum-projection-of-3D-images-along-the-Y-axis,-then-stack-them." title="Permalink"></a></h6><pre><code class="language-toml hljs">file_lists = [{name=&quot;3dstack.tif&quot;, transformer=[&quot;reduce_images&quot;, [&quot;maximum&quot;, 2]],aggregator=&quot;stack_images&quot;}]</code></pre><h6 id="Describe-intensity-of-each-image,-per-slice,-and-concatenate-to-table"><a class="docs-heading-anchor" href="#Describe-intensity-of-each-image,-per-slice,-and-concatenate-to-table">Describe intensity of each image, per slice, and concatenate to table</a><a id="Describe-intensity-of-each-image,-per-slice,-and-concatenate-to-table-1"></a><a class="docs-heading-anchor-permalink" href="#Describe-intensity-of-each-image,-per-slice,-and-concatenate-to-table" title="Permalink"></a></h6><pre><code class="language-toml hljs">file_lists = [{name=&quot;image_stats&quot;, transformer=[&quot;describe_image&quot;, 3], aggregator=&quot;concat_to_table&quot;}]</code></pre><p>For each image added to the list, it&#39;ll slice the image along the z axis and create a table with statistics on intensity (min, mean, std, kurtosis, Q1, ...), for example:</p><pre><code class="language-bash hljs">│  Row │ minimum     Q1        mean      median    Q3        maximum   std       kurtosis  slice  axis   source
│      │ Float64     Float64   Float64   Float64   Float64   Float64   Float64   Float64   Int64  Int64  String7
│─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────
│    1 │ 0.00784314  0.245098  0.508418  0.501961  0.760784  0.996078  0.291711   6.71003      1      3  1.tif
│    2 │ 0.00392157  0.242157  0.490539  0.482353  0.741176  1.0       0.290982   6.60052      2      3  1.tif
...</code></pre><h6 id="Stack-images,-sorting-by-prefix"><a class="docs-heading-anchor" href="#Stack-images,-sorting-by-prefix">Stack images, sorting by prefix</a><a id="Stack-images,-sorting-by-prefix-1"></a><a class="docs-heading-anchor-permalink" href="#Stack-images,-sorting-by-prefix" title="Permalink"></a></h6><p>Sometimes image datasets have files like</p><pre><code class="language-bash hljs">root
├── patient1
│   ├── patient1_slice_1.tif
│   └── patient1_slice_2.tif
│   └── ...
├── patient2
│   ├── patient2_slice_1.tif
│   └── patient2_slice_2.tif
│   └── ...
...</code></pre><p>We&#39;d like to combine these into</p><pre><code class="language-bash hljs">- patient1.tif (3D)
- patient2.tif (3D)</code></pre><p>The solution is straightforward, we aggregate but ask to group by prefix</p><pre><code class="language-toml hljs">file_lists = [{name=&quot;slices&quot;, aggregator=&quot;stack_images_by_prefix&quot;}]</code></pre><h5 id="Table-aggregation"><a class="docs-heading-anchor" href="#Table-aggregation">Table aggregation</a><a id="Table-aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#Table-aggregation" title="Permalink"></a></h5><pre><code class="language-toml hljs">file_lists = [{name=&quot;all_ab_columns.csv&quot;, transformer=[&quot;extract_columns&quot;, [&quot;A&quot;, &quot;B&quot;]], aggregator=&quot;concat_to_table&quot;}]</code></pre><h3 id="Template"><a class="docs-heading-anchor" href="#Template">Template</a><a id="Template-1"></a><a class="docs-heading-anchor-permalink" href="#Template" title="Permalink"></a></h3><p>A template has 2 kind of entries <code>[any]</code> and <code>[level_X]</code>. You will only see the level_X entries in hierarchical templates, then X specifies at which depth you want to check a rule.</p><h4 id="Flat-templates,-the-Any-section"><a class="docs-heading-anchor" href="#Flat-templates,-the-Any-section">Flat templates, the Any section</a><a id="Flat-templates,-the-Any-section-1"></a><a class="docs-heading-anchor-permalink" href="#Flat-templates,-the-Any-section" title="Permalink"></a></h4><pre><code class="language-toml hljs">[any]
all=false #default, if true, fuses all conditions and actions. If false, you list condition-action pairs.
conditions=[&quot;is_tif_file&quot;, [&quot;has_n_files&quot;, 10]]
actions=[&quot;show_warning&quot;, [&quot;log_to_file&quot;, &quot;decathlon.txt&quot;]]
counter_actions=[[&quot;add_to_file_list&quot;, &quot;mylist&quot;], [&quot;log_to_file&quot;, &quot;not_decathlon.txt&quot;]] ## Optional</code></pre><p>The <code>add_to_file_list</code> will pass any file or directory for which <code>is_tif_file</code> = true (see <code>act_on_success</code>) to a list you defined earlier called &quot;mylist&quot;. You specified in the global section what needs to be done with those files at the end. You do not need counter_actions.</p><div class="admonition is-success"><header class="admonition-header">Negation and logical and</header><div class="admonition-body"><p>You can also negate and fuse conditions/actions. Actions can not be negated.</p><pre><code class="language-toml hljs">conditions=[[&quot;not&quot;, &quot;is_tif_file&quot;], [&quot;all&quot;, &quot;is_2d_img&quot;, &quot;is_rgb&quot;]]]</code></pre><p>This is useful if you want to check for multiple things, but each can be quite complex. In other words, you want pairs of condition-action, so all=false, yet each pair is a complex rule.</p></div></div><h4 id="Hierarchical-templates,-with-level_X"><a class="docs-heading-anchor" href="#Hierarchical-templates,-with-level_X">Hierarchical templates, with <code>level_X</code></a><a id="Hierarchical-templates,-with-level_X-1"></a><a class="docs-heading-anchor-permalink" href="#Hierarchical-templates,-with-level_X" title="Permalink"></a></h4><p>All you now need to add is what to do at level &#39;X&#39;</p><pre><code class="language-toml hljs">[global]
hierarchical=true
...
[level_3]
conditions=...
actions=...
...</code></pre><p>This will only be applied if, and only if, files and directories 3 levels (directories) deep are encountered.</p><p>Sometimes you do not know how deep your dataset can be, in that case you&#39;ll want a &#39;catch-all&#39;, in hierarchical templates this is now the role of <code>any</code></p><pre><code class="language-toml hljs">[global]
act_on_success=true
[any]
conditions=[&quot;is_csv_file&quot;]
actions=[&quot;show_warning&quot;]
[level_3]
conditions=[&quot;is_tif_file&quot;, &quot;is_csv_file&quot;]
actions=[[&quot;log_to_file&quot;, &quot;tiffiles.txt&quot;], &quot;show_warning&quot;]</code></pre><p>This tiny template will write any tif file to tiffiles.txt. If it encounters csv files anywhere else, it will warn you.</p><p>Please see the directory <a href="../../example_recipes">example_recipes</a> for more complex examples.</p><h3 id="Advanced-usage"><a class="docs-heading-anchor" href="#Advanced-usage">Advanced usage</a><a id="Advanced-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-usage" title="Permalink"></a></h3><h5 id="Verify-a-complex,-deep-dataset-layout."><a class="docs-heading-anchor" href="#Verify-a-complex,-deep-dataset-layout.">Verify a complex, deep dataset layout.</a><a id="Verify-a-complex,-deep-dataset-layout.-1"></a><a class="docs-heading-anchor-permalink" href="#Verify-a-complex,-deep-dataset-layout." title="Permalink"></a></h5><p>This is an example of a real world dataset, with comments.</p><p>An example of a &#39;curated&#39; dataset would look like this</p><pre><code class="language-bash hljs">root
├── 1                           # replicate number, &gt; 0
│   ├── condition_1             # celltype or condition  # &lt;- different types of GANs for generating data
│   │   ├── Series005           # cell number
│   │   │   ├── channel_1.tif   # first channel, 3D Gray scale, 16 bit
│   │   │   ├── channel_2.tif   # second channel, 3D Gray scale, 16 bit
...
├── 2
...</code></pre><p>Let&#39;s create a <code>recipe</code> for this dataset that simply warns for anything unexpected.</p><h6 id="Global-section-2"><a class="docs-heading-anchor" href="#Global-section-2">Global section</a><a class="docs-heading-anchor-permalink" href="#Global-section-2" title="Permalink"></a></h6><p>We&#39;re validating data, so we&#39;ll specify what should be true, and only if our rules are violated, do we act. Hence <code>act_on_success=false</code>, which is the default. We have different rules depending on where in the hierarchy we check, so <code>hierarchical=true</code>. And finally, we need a place to start, so <code>inputdirectory=root</code></p><pre><code class="language-toml hljs">[global]
hierarchical=true
inputdirectory = &quot;root&quot;</code></pre><h6 id="The-template"><a class="docs-heading-anchor" href="#The-template">The template</a><a id="The-template-1"></a><a class="docs-heading-anchor-permalink" href="#The-template" title="Permalink"></a></h6><p>We specify what to do if we see anything that does not catch our (5-level) deep <code>recipe</code>, in the <code>[any]</code> section.</p><pre><code class="language-toml hljs">[any]
conditions=[&quot;always_fails&quot;]        #if this rule ever is checked, say at level 10, it fails immediately
actions = [&quot;show_warning&quot;]</code></pre><p>Next, we define rules for each level. Levels:</p><pre><code class="language-toml hljs">## Top directory &#39;root&#39;, should only contain sub directories

[level_1]
conditions=[&quot;isdir&quot;]
actions = [&quot;show_warning&quot;]   # if we see a file, isdir-&gt;false, so show a warning
## Replicate directory, should be an integer

[level_2]
all=true
conditions=[&quot;isdir&quot;, &quot;integer_name&quot;]  # again, no files, only subdirectories
actions = [&quot;show_warning&quot;]

## We don&#39;t care what cell types are named, as long as there&#39;s not unexpected data

[level_3]
conditions=[&quot;isdir&quot;]
actions = [&quot;show_warning&quot;]

## Final level, directory with 2 files, and should end with cell nr
[level_4]
all=true
conditions=[&quot;isdir&quot;, [&quot;has_n_files&quot;, 2], [&quot;ends_with_integer&quot;]]
actions = [&quot;show_warning&quot;]

## The actual files, we complain if there&#39;s any subdirectories, or if the files are not 3D
[level_5]
all=true
conditions=[&quot;is_tif_file&quot;, [&quot;endswith&quot;, &quot;[1,2].tif&quot;], [&quot;not&quot;, &quot;is_rgb&quot;], &quot;is_3d_img&quot;,]
actions = [&quot;show_warning&quot;]</code></pre><div class="admonition is-success"><header class="admonition-header">Short circuit to help to speed up conditions</header><div class="admonition-body"><p>Note that we first check the file extension <code>is_tif_file</code>, and only then check the pattern <code>endswidth ...</code>, and only then actually look at the image type. Checking if an image is 3D or RGB requires loading it. Loading (potentially huge) files is slow and expensive, so this could mean we&#39;d check &#39;is<em>3d</em>img&#39; for a csv file, which would fail, but in a very expensive way. Instead, our conditions <code>short circuit</code>. We specified <code>all=true</code>, so each of them has to be true, if 1 fails we don&#39;t need to check the others. By putting <code>is_tif_file</code> first, we avoid having to even load the file to check its contents. This is done <strong>automatically</strong> for you, as long as you keep to the left-right ordering, in general of <code>cheap</code>(or least strict) to <code>expensive</code> (most strict). In practice for this dataset, this means a runtime gain of 50-90% depending on how much invalid data there is.</p></div></div><h5 id="Early-exit:"><a class="docs-heading-anchor" href="#Early-exit:">Early exit:</a><a id="Early-exit:-1"></a><a class="docs-heading-anchor-permalink" href="#Early-exit:" title="Permalink"></a></h5><p>sometimes you want the validation or processing to stop immediately based on a condition, e.g. finding corrupt data, or because you&#39;re just looking for 1 specific type of conditions. This can be achieved fairly easily, illustrated with a trivial example that stops after finding something other than .txt files.</p><pre><code class="language-toml hljs">[global]
act_on_success = false
inputdirectory = &quot;testdir&quot;
[any]
all = true
conditions = [&quot;isfile&quot;, [&quot;endswith&quot;, &quot;.txt&quot;]]
actions = [&quot;halt&quot;]</code></pre><h5 id="Regular-expressions:"><a class="docs-heading-anchor" href="#Regular-expressions:">Regular expressions:</a><a id="Regular-expressions:-1"></a><a class="docs-heading-anchor-permalink" href="#Regular-expressions:" title="Permalink"></a></h5><p>For more advanced users, when you write &quot;startswith&quot; &quot;*.txt&quot;, it will not match anything, because by default regular expressions are disabled. Enabling them is easy though</p><pre><code class="language-toml hljs">[global]
regex=true
...
condition = [&quot;startswith&quot;, &quot;[0-9]+&quot;]</code></pre><p>This will now match files with 1 or more integers at the beginning of the file name.</p><p>!!! note Regex compilation errors on &quot;<em>patterns&quot;     If you try to pass a regex such as &quot;</em>.txt&quot;, you&#39;ll get an error complaining about PCRE not being able to compile your Regex. The reason for this is the lookahead/lookback functionality in the Regex engine not allowing such wildcards at the beginning of a regex. When you write &quot; <em>.txt &quot;, what you probably meant was &#39;anything with extension txt&#39;, but not the name &quot;.txt&quot;, which &quot; *.txt &quot; will also match. Instead, use &quot;.\</em>.txt&quot;. When in doubt, don&#39;t use a regex if you can avoid it. Similar to Kruger-Dunning, those who believe they can wield a regex with confidence, probably shouldn&#39;t.</p><h5 id="Negating-conditions:"><a class="docs-heading-anchor" href="#Negating-conditions:">Negating conditions:</a><a id="Negating-conditions:-1"></a><a class="docs-heading-anchor-permalink" href="#Negating-conditions:" title="Permalink"></a></h5><p>By default your conditions are &#39;OR&#39;ed, and by setting all=yes, you have &#39;AND&#39;. By flipping action<em>on</em>succes you can negate all conditions. So in essence you don&#39;t need more than that for all combinations, but if you need to specifically flip 1 condition, this will get messy. Instead, you can negate any condition by giving it a prefix argumet of &quot;not&quot;.</p><pre><code class="language-toml hljs">[global]
act_on_success = true
inputdirectory = &quot;testdir&quot;
regex=true
[any]
all=true
conditions = [&quot;isfile&quot;, [&quot;not&quot;, &quot;endswith&quot;, &quot;.*.txt&quot;]]
actions = [[&quot;flatten_to&quot;, &quot;outdir&quot;], &quot;show_warning&quot;]</code></pre><h5 id="Counteractions:"><a class="docs-heading-anchor" href="#Counteractions:">Counteractions:</a><a id="Counteractions:-1"></a><a class="docs-heading-anchor-permalink" href="#Counteractions:" title="Permalink"></a></h5><p>When you&#39;re validating you&#39;ll want to warn/log invalid files/folders. But at the same time, you may want to do the actual preprocessing as well. This is where counteractions come in, they allow you to specify</p><ul><li>Do x when condition = true</li><li>Do y when condition = false</li></ul><p>A simple example, filtering by file type:</p><pre><code class="language-toml hljs">[global]
act_on_success=true
inputdirectory = &quot;testdir&quot;
[any]
conditions=[&quot;is_csv_file&quot;]
actions=[[&quot;log_to_file&quot;, &quot;csvs.txt&quot;]]
counter_actions = [[&quot;log_to_file&quot;, &quot;non_csvs.txt&quot;]]</code></pre><p>or another use case is deleting a file that&#39;s incorrect, while transforming correct files in preparation for a pipeline, in 1 step.</p><h5 id="Export-to-HDF5/MAT"><a class="docs-heading-anchor" href="#Export-to-HDF5/MAT">Export to HDF5/MAT</a><a id="Export-to-HDF5/MAT-1"></a><a class="docs-heading-anchor-permalink" href="#Export-to-HDF5/MAT" title="Permalink"></a></h5><p>You can save/export directly to HDF5 and MAT, so if you&#39;re curating a dataset consisting of files, but your pipeline (for good reason) works on HDF5, you can do so easily.</p><pre><code class="language-toml hljs">[global]
...
[any]
conditions = [&quot;is_tif_file&quot;, &quot;is_csv_file&quot;]
actions=[[&quot;add_to_hdf5&quot;, &quot;img.hdf5&quot;], [&quot;add_to_mat&quot;, &quot;csv.mat&quot;]]</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The filename will be used as entry/variable in the MAT or HDF5 file, e.g. file-&gt;content.</p></div></div><h2 id="Modifying-files-and-content"><a class="docs-heading-anchor" href="#Modifying-files-and-content">Modifying files and content</a><a id="Modifying-files-and-content-1"></a><a class="docs-heading-anchor-permalink" href="#Modifying-files-and-content" title="Permalink"></a></h2><p>When you want precise control over what function runs on the content, versus the name of files, you can do so. This example finds all 3D tif files, does a median projection along Z, then masks (binarizes) the image as a copy with original filename in lowercase.</p><pre><code class="language-toml hljs">[global]
act_on_success=true
inputdirectory = &quot;testdir&quot;
[any]
conditions=[&quot;is_3d_img&quot;]
actions=[{name_transform=[&quot;tolowercase&quot;], content_transform=[[&quot;reduce_image&quot;, [&quot;maximum&quot;, 2]], &quot;mask&quot;], mode=&quot;copy&quot;}]</code></pre><p>The examples so far use <code>syntactic sugar</code>, they&#39;re shorter ways of writing the below, but in certain case where you need to get a lot done, this full syntax is more descriptive, and less error prone. It also gives DataCurator the opportunity to save otherwise excessive intermediate copies.</p><p>The full syntax for actions of this kind:</p><pre><code class="nohighlight hljs">actions=[{name_transform=[entry+], content_transform=[entry+], mode=&quot;copy&quot; | &quot;move&quot; | &quot;inplace&quot;}+]</code></pre><p>Where <code>entry</code> is any set of functions with arguments. The + sign indicates &quot;one or more&quot;. The | symbol indicates &#39;OR&#39;, e.g. either copy, move, or inplace.</p><h4 id="Select-rows-from-CSVs-and-save-them"><a class="docs-heading-anchor" href="#Select-rows-from-CSVs-and-save-them">Select rows from CSVs and save them</a><a id="Select-rows-from-CSVs-and-save-them-1"></a><a class="docs-heading-anchor-permalink" href="#Select-rows-from-CSVs-and-save-them" title="Permalink"></a></h4><pre><code class="language-toml hljs">[global]
act_on_success=true
inputdirectory = &quot;testdir&quot;
[any]
all=true
conditions=[&quot;is_csv_file&quot;, &quot;has_upper&quot;]
actions=[{name_transform=[&quot;tolowercase&quot;], content_transform=[[&quot;extract&quot;, (&quot;Count&quot;, &quot;less&quot;, 10)]], mode=&quot;copy&quot;}]</code></pre><p>Table extraction has the following syntax:</p><pre><code class="language-toml hljs">[&quot;extract&quot;, (col, op, vals)]</code></pre><p>or</p><pre><code class="language-toml hljs">[&quot;extract&quot;, (col, op)]</code></pre><p>Wich then turns into:</p><pre><code class="language-julia hljs">select rows where op1(col1, vals1) &amp;&amp; op2(col2, vals2)</code></pre><p>For example:</p><pre><code class="language-toml hljs">[&quot;extract&quot;, (&quot;name&quot;,&quot;=&quot;,&quot;Bert&quot;),  (&quot;count&quot;, &quot;&lt;&quot;, 10)]</code></pre><p>Gives you a copy of the table with only rows where name=&#39;Bert&#39; and count&lt;10.</p><p>List of operators:</p><pre><code class="language-julia hljs">less, leq, smaller than, more, greater than, equals, euqal, is, geq, isnan, isnothing, ismissing, iszero, &lt;, &gt;, &lt;=, &gt;=, ==, =, in, between, [not, operator]</code></pre><p>The operators <code>in</code> and <code>between</code> expect an array of values:</p><pre><code class="language-julia hljs">(&#39;count&#39;, &#39;in&#39;, [2,3,5])</code></pre><p>and</p><pre><code class="language-julia hljs">(&#39;count&#39;, &#39;between&#39;, [0,100])</code></pre><p>where the last is equivalent, but shorter (and faster) than:</p><pre><code class="language-julia hljs">(&#39;count&#39;, &#39;&gt;&#39;, 0), (&#39;count&#39;, &#39;&lt;&#39;, 100)</code></pre><h3 id="Aggregation-2"><a class="docs-heading-anchor" href="#Aggregation-2">Aggregation</a><a class="docs-heading-anchor-permalink" href="#Aggregation-2" title="Permalink"></a></h3><p>When you need group data before processing it, such as collecting files to count their size, write input-output pairs, or stack images, and so forth, you&#39;re performing a pattern of the form</p><pre><code class="language-julia hljs">output = reduce(aggregator, map(transform, filter(test, data)))</code></pre><p>Sounds complex, but it&#39;s intuitive, you</p><ul><li>collect data based on some condition (filter)</li><li>transform it in some way (e.g. mask images, copy, ...)</li><li>group the output and reduce it (all filenames to 1 file, ...)</li></ul><p>Examples of this use case:</p><ul><li>Collect all CSV files, concat to 1 table</li><li>Collect columns &quot;x2&quot; and &quot;x3&quot; of CSV files whose name contains &quot;infected_C19&quot;, and concat to 1 table</li><li>Collect all 2D images, and save to 1 3D stack</li><li>Collect all 3D images, and save maximum/minimum/mean/median projection</li></ul><p>The 2nd example is simply:</p><pre><code class="language-toml hljs">[global]
...
file_lists=[{name=&quot;group&quot;, transformer=[&quot;extract_columns&quot;, [&quot;x2&quot;, &quot;x3&quot;]], aggregator=&quot;concat_to_table&quot;}]
...
[any]
all=true
conditions=[&quot;is_csv_file&quot;, [&quot;contains&quot;, &quot;infected_C19&quot;]]
actions=[[&quot;add_to_file_list&quot;, &quot;group&quot;]]</code></pre><h4 id="The-maximum-projection-of-2D-images"><a class="docs-heading-anchor" href="#The-maximum-projection-of-2D-images">The maximum projection of 2D images</a><a id="The-maximum-projection-of-2D-images-1"></a><a class="docs-heading-anchor-permalink" href="#The-maximum-projection-of-2D-images" title="Permalink"></a></h4><pre><code class="language-toml hljs">[global]
...
file_lists=[{name=&quot;group&quot;, aggregator=[&quot;reduce_images&quot;, &quot;maximum&quot;]}]
...
[any]
conditions=[&quot;is_2d_img&quot;]
actions=[[&quot;add_to_file_list&quot;, &quot;group&quot;]]</code></pre><h4 id="The-complete-grammar:"><a class="docs-heading-anchor" href="#The-complete-grammar:">The complete grammar:</a><a id="The-complete-grammar:-1"></a><a class="docs-heading-anchor-permalink" href="#The-complete-grammar:" title="Permalink"></a></h4><pre><code class="language-toml hljs">file_lists=[{name=name, transformer=identity, aggregator=shared_list_to_file}+]</code></pre><p>(X+) indicates at least one of X</p><p>The following aliases save you typing:</p><pre><code class="language-toml hljs">file_lists=[&quot;name&quot;]
# is the same as
file_lists=[{name=name, transformer=identity, aggregator=shared_list_to_file}]</code></pre><pre><code class="language-toml hljs">file_lists=[[&quot;name&quot;, &quot;some_directory&quot;]]
# is the same as
file_lists=[{name=name, transformer=change_path, aggregator=shared_list_to_file}]</code></pre><p>You&#39;re free to specify as many aggregators as you like.</p><h2 id="Under-the-hood"><a class="docs-heading-anchor" href="#Under-the-hood">Under the hood</a><a id="Under-the-hood-1"></a><a class="docs-heading-anchor-permalink" href="#Under-the-hood" title="Permalink"></a></h2><p>When you define a template, a &#39;visitor&#39; will walk over each &#39;node&#39; in the filesystem graph, testing any conditions when appropriate, and executing actions or counteractions. <img src="concept.png" alt="Concept"/></p><p>In the background there&#39;s a lot more going on</p><ul><li>Managing threadsafe data structures</li><li>Resolving counters and file lists</li><li>Looking up functions</li><li>Composing functions and conditions</li><li>...</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="installation.html">« Installation</a><a class="docs-footer-nextpage" href="reference.html">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Sunday 10 April 2022 11:40">Sunday 10 April 2022</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
